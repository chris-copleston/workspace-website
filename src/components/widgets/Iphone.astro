---
interface Props {
  item: {
    img: string;
    color: string[];
  };
  start?: {
    x: number;
    y: number;
    z: number;
  };
  end?: {
    x: number;
    y: number;
    z: number;
  };
  timeline?: gsap.core.Timeline;
  enableOrbitControls?: boolean;
  enableAutoRotation?: boolean;
}

const { item, start = { x: 0, y: 0, z: 10 }, end = { x: 0, y: 0, z: 10 }, timeline, enableOrbitControls = false, enableAutoRotation = false } = Astro.props;
---

<div class="relative w-full h-full">
  <div class="absolute inset-0 flex items-center justify-center">
    <div 
      class="w-full h-full iphone-canvas-container" 
      data-screen-img={item.img} 
      data-phone-color={item.color[0]}
      data-start-x={start.x}
      data-start-y={start.y}
      data-start-z={start.z}
      data-end-x={end.x}
      data-end-y={end.y}
      data-end-z={end.z}
      data-has-timeline={!!timeline}
      data-enable-orbit-controls={enableOrbitControls}
      data-enable-auto-rotation={enableAutoRotation}
    ></div>
  </div>
</div>

<script>
  import * as THREE from 'three';
  import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';
  import { DRACOLoader } from 'three/examples/jsm/loaders/DRACOLoader.js';
  import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';
  import { gsap } from 'gsap';
  import { ScrollTrigger } from 'gsap/ScrollTrigger';

  // Register ScrollTrigger plugin
  gsap.registerPlugin(ScrollTrigger);

  class IPhoneRenderer {
    constructor(container) {
      // console.log('Initializing iPhone renderer');
      // console.log('Screen image path:', container.dataset.screenImg);
      // console.log('Phone color:', container.dataset.phoneColor);
      
      // Initialize Three.js scene
      const scene = new THREE.Scene();
      
      // Create camera
      const camera = new THREE.PerspectiveCamera(45, container.clientWidth / container.clientHeight, 0.1, 1000);
      const startPos = { 
        x: parseFloat(container.dataset.startX || '0'),
        y: parseFloat(container.dataset.startY || '0'),
        z: parseFloat(container.dataset.startZ || '10')
      };
      
      // Set initial camera position from start values
      camera.position.set(startPos.x, startPos.y, startPos.z);
      
      // Create renderer
      const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      renderer.setSize(container.clientWidth, container.clientHeight);
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.shadowMap.enabled = true;
      renderer.outputEncoding = THREE.sRGBEncoding;
      container.appendChild(renderer.domElement);
      
      // Add OrbitControls
      const enableOrbitControls = container.dataset.enableOrbitControls === 'true';
      const enableAutoRotation = container.dataset.enableAutoRotation === 'true';
      let controls;
      if (enableOrbitControls) {
        controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.enableZoom = false;
        
        // Log initial control settings
        // console.log('Orbital Controls Settings:', {
        //   enableDamping: controls.enableDamping,
        //   dampingFactor: controls.dampingFactor,
        //   enableZoom: controls.enableZoom,
        //   enabled: controls.enabled
        // });

        // Add event listeners for control changes
        // controls.addEventListener('change', () => {
        //   console.log('Camera Position:', {
        //     x: camera.position.x.toFixed(2),
        //     y: camera.position.y.toFixed(2),
        //     z: camera.position.z.toFixed(2)
        //   });
        //   console.log('Controls Target:', {
        //     x: controls.target.x.toFixed(2),
        //     y: controls.target.y.toFixed(2),
        //     z: controls.target.z.toFixed(2)
        //   });
        // });
      }

      // Set up scroll-based animation
      const endPos = {
        x: parseFloat(container.dataset.endX || '0'),
        y: parseFloat(container.dataset.endY || '0'),
        z: parseFloat(container.dataset.endZ || '10')
      };

      // Check if a timeline is provided
      const hasTimeline = container.dataset.hasTimeline === 'true';

      if (!hasTimeline) {
        // Create default scroll trigger animation using start/end positions
        gsap.to(camera.position, {
          scrollTrigger: {
            trigger: container,
            start: "top bottom",
            end: "bottom top",
            scrub: 2,
            onUpdate: (self) => {
              const progress = self.progress;
              camera.position.x = startPos.x + (endPos.x - startPos.x) * progress;
              camera.position.y = startPos.y + (endPos.y - startPos.y) * progress;
              camera.position.z = startPos.z + (endPos.z - startPos.z) * progress;
            }
          }
        });
      } else {
        // Set initial camera position
        camera.position.set(startPos.x, startPos.y, startPos.z);
      }
      
      // Set up DRACO loader
      const dracoLoader = new DRACOLoader();
      dracoLoader.setDecoderPath('https://www.gstatic.com/draco/versioned/decoders/1.5.6/');
      
      // Add environment map
      const pmremGenerator = new THREE.PMREMGenerator(renderer);
      pmremGenerator.compileEquirectangularShader();
      
      const cubeRenderTarget = pmremGenerator.fromScene(new THREE.Scene());
      const envMap = cubeRenderTarget.texture;
      
      // Load model
      const loader = new GLTFLoader();
      loader.setDRACOLoader(dracoLoader);
      
      // console.log('Loading model from:', '/models/scene.glb');
      
      loader.load('/models/scene.glb', 
        // Success callback
        (gltf) => {
          // console.log('Model loaded successfully');
          const model = gltf.scene;
          
          // Center the model
          const box = new THREE.Box3().setFromObject(model);
          const center = box.getCenter(new THREE.Vector3());
          const size = box.getSize(new THREE.Vector3());
          
          // Adjust scale based on size
          const maxDim = Math.max(size.x, size.y, size.z);
          const scale = 7 / maxDim;
          model.scale.setScalar(scale);
          
          // Center the model
          model.position.sub(center.multiplyScalar(scale));
          
          // Rotate the model to show screen side
          model.rotation.y = Math.PI;
          
          // Update materials
          model.traverse((child) => {
            if (child.isMesh) {
              // console.log('Processing mesh:', child.name);
              const materialName = child.material.name;
              
              // Create titanium material for the edges
              const titaniumMaterial = new THREE.MeshStandardMaterial({
                color: 0xD3D3D3,  // Light gray base color
                metalness: 0.9,    // High metalness for metallic look
                roughness: 0.3,    // Lower roughness for slight shine
                envMap: envMap,    // Add environment map
                envMapIntensity: 1.2  // Enhance environment reflections
              });
              
              if (
                materialName !== "zFdeDaGNRwzccye" &&
                materialName !== "ujsvqBWRMnqdwPx" &&
                materialName !== "hUlRcbieVuIiOXG" &&
                materialName !== "jlzuBkUzuJqgiAK" &&
                materialName !== "xNrofRCqOXXHVZt"
              ) {
                // Apply titanium material to the edges
                child.material = titaniumMaterial;
              }
              
              // Apply texture to specific mesh
              if (child.name === "xXDHkMplTIDAXLN") {
                // console.log('Found screen mesh:', child.name);
                const textureLoader = new THREE.TextureLoader();
                const screenImagePath = container.dataset.screenImg;
                
                if (screenImagePath) {
                  textureLoader.load(
                    screenImagePath,
                    (texture) => {
                      texture.encoding = THREE.LinearEncoding;
                      texture.colorSpace = THREE.SRGBColorSpace;
                      texture.flipY = true;
                      child.material = new THREE.MeshStandardMaterial({
                        map: texture,
                        roughness: 0,
                        metalness: 0.0,
                        transparent: true,
                        opacity: 1,
                        emissive: 0xffffff,
                        emissiveMap: texture,
                        emissiveIntensity: 0.5
                      });
                    }
                  );
                }
              }
            }
          });
          
          scene.add(model);
          
          // Animation loop
          const animate = () => {
            requestAnimationFrame(animate);
            // console.log('enableOrbitControls', enableOrbitControls);
            
            if (enableOrbitControls && controls) {
              controls.update();
            } else if (enableAutoRotation && model) {
              // Auto rotation only when enabled and no orbit controls
              model.rotation.y += 0.005;
            }
            
            renderer.render(scene, camera);
          };
          animate();
        }
      );
      
      // Add lights
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
      scene.add(ambientLight);
      
      const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
      directionalLight.position.set(5, 5, 5);
      directionalLight.castShadow = true;
      scene.add(directionalLight);
      
      // Add fill lights for better metal reflection
      const fillLight1 = new THREE.DirectionalLight(0xffffff, 0.8);
      fillLight1.position.set(-5, 0, 2);
      scene.add(fillLight1);
      
      const fillLight2 = new THREE.DirectionalLight(0xffffff, 0.8);
      fillLight2.position.set(5, 0, -2);
      scene.add(fillLight2);
      
      // Handle window resize
      window.addEventListener('resize', () => {
        camera.aspect = container.clientWidth / container.clientHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(container.clientWidth, container.clientHeight);
      });
    }
  }
  
  // Initialize the renderer when the page loads
  document.addEventListener('astro:page-load', () => {
    const containers = document.querySelectorAll('.iphone-canvas-container');
    containers.forEach(container => {
      if (container) {
        new IPhoneRenderer(container);
      }
    });
  });
</script>

<style>
  #iphone-container {
    display: block;
    width: 100%;
    height: 100%;
  }
  
  .iphone-canvas-container {
    position: relative;
    width: 100%;
    height: 100%;
  }
  
  .iphone-canvas-container canvas {
    width: 100% !important;
    height: 100% !important;
  }
</style>