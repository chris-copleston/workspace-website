---
interface Props {
  item: {
    img: string;
    color: string[];
  };
  enableOrbitControls?: boolean;
  enableAutoRotation?: boolean;
}

const { item, enableOrbitControls = false, enableAutoRotation = false } = Astro.props;
---

<div class="relative w-full h-full">
  <div class="absolute inset-0 flex items-center justify-center">
    <div 
      class="w-full h-full" 
      id="canvas-container" 
      data-screen-img={item.img} 
      data-phone-color={item.color[0]}
      data-enable-orbit-controls={enableOrbitControls}
      data-enable-auto-rotation={enableAutoRotation}
    ></div>
  </div>
</div>

<script>
  import * as THREE from 'three';
  import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';
  import { DRACOLoader } from 'three/examples/jsm/loaders/DRACOLoader.js';
  import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';
  
  class IPhoneRenderer {
    constructor(container) {
      console.log('Initializing iPhone renderer');
      console.log('Screen image path:', container.dataset.screenImg);
      console.log('Phone color:', container.dataset.phoneColor);
      
      // Initialize Three.js scene
      const scene = new THREE.Scene();
      
      // Create camera
      const camera = new THREE.PerspectiveCamera(45, container.clientWidth / container.clientHeight, 0.1, 1000);
      camera.position.z = 10;
      
      // Create renderer
      const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      renderer.setSize(container.clientWidth, container.clientHeight);
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.shadowMap.enabled = true;
      renderer.outputEncoding = THREE.sRGBEncoding;
      container.appendChild(renderer.domElement);
      
      // Add OrbitControls
      const enableOrbitControls = container.dataset.enableOrbitControls === 'true';
      const enableAutoRotation = container.dataset.enableAutoRotation === 'true';
      let controls;
      if (enableOrbitControls) {
        controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.enableZoom = false;
      }
      
      // Set up DRACO loader
      const dracoLoader = new DRACOLoader();
      dracoLoader.setDecoderPath('https://www.gstatic.com/draco/versioned/decoders/1.5.6/');
      
      // Add environment map
      const pmremGenerator = new THREE.PMREMGenerator(renderer);
      pmremGenerator.compileEquirectangularShader();
      
      const cubeRenderTarget = pmremGenerator.fromScene(new THREE.Scene());
      const envMap = cubeRenderTarget.texture;
      
      // Load model
      const loader = new GLTFLoader();
      loader.setDRACOLoader(dracoLoader);
      
      console.log('Loading model from:', '/models/scene.glb');
      
      loader.load('/models/scene.glb', 
        // Success callback
        (gltf) => {
          console.log('Model loaded successfully');
          const model = gltf.scene;
          
          // Center the model
          const box = new THREE.Box3().setFromObject(model);
          const center = box.getCenter(new THREE.Vector3());
          const size = box.getSize(new THREE.Vector3());
          
          // Adjust scale based on size
          const maxDim = Math.max(size.x, size.y, size.z);
          const scale = 5 / maxDim;
          model.scale.setScalar(scale);
          
          // Center the model
          model.position.sub(center.multiplyScalar(scale));
          
          // Rotate the model to show screen side
          model.rotation.y = Math.PI;
          
          // Update materials
          model.traverse((child) => {
            if (child.isMesh) {
              console.log('Processing mesh:', child.name);
              const materialName = child.material.name;
              
              // Create titanium material for the edges
              const titaniumMaterial = new THREE.MeshStandardMaterial({
                color: 0xD3D3D3,  // Light gray base color
                metalness: 0.9,    // High metalness for metallic look
                roughness: 0.3,    // Lower roughness for slight shine
                envMap: envMap,    // Add environment map
                envMapIntensity: 1.2  // Enhance environment reflections
              });
              
              if (
                materialName !== "zFdeDaGNRwzccye" &&
                materialName !== "ujsvqBWRMnqdwPx" &&
                materialName !== "hUlRcbieVuIiOXG" &&
                materialName !== "jlzuBkUzuJqgiAK" &&
                materialName !== "xNrofRCqOXXHVZt"
              ) {
                // Apply titanium material to the edges
                child.material = titaniumMaterial;
              }
              
              // Apply texture to specific mesh
              if (child.name === "xXDHkMplTIDAXLN") {
                console.log('Found screen mesh:', child.name);
                const textureLoader = new THREE.TextureLoader();
                const screenImagePath = container.dataset.screenImg;
                
                if (screenImagePath) {
                  textureLoader.load(
                    screenImagePath,
                    (texture) => {
                      texture.encoding = THREE.sRGBEncoding;
                      texture.flipY = false;
                      child.material = new THREE.MeshStandardMaterial({
                        map: texture,
                        roughness: 0.2,
                        metalness: 0.0,
                        transparent: true,
                        opacity: 1,
                      });
                    }
                  );
                }
              }
            }
          });
          
          scene.add(model);
          
          // Animation loop
          const animate = () => {
            requestAnimationFrame(animate);
            
            if (enableOrbitControls && controls) {
              controls.update();
            } else if (enableAutoRotation && model) {
              // Auto rotation only when enabled and no orbit controls
              model.rotation.y += 0.005;
            }
            
            renderer.render(scene, camera);
          };
          animate();
        }
      );
      
      // Add lights
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
      scene.add(ambientLight);
      
      const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
      directionalLight.position.set(5, 5, 5);
      directionalLight.castShadow = true;
      scene.add(directionalLight);
      
      // Add fill lights for better metal reflection
      const fillLight1 = new THREE.DirectionalLight(0xffffff, 0.8);
      fillLight1.position.set(-5, 0, 2);
      scene.add(fillLight1);
      
      const fillLight2 = new THREE.DirectionalLight(0xffffff, 0.8);
      fillLight2.position.set(5, 0, -2);
      scene.add(fillLight2);
      
      // Handle window resize
      window.addEventListener('resize', () => {
        camera.aspect = container.clientWidth / container.clientHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(container.clientWidth, container.clientHeight);
      });
    }
  }
  
  // Initialize the renderer when the DOM is loaded
  document.addEventListener('DOMContentLoaded', () => {
    const container = document.getElementById('canvas-container');
    if (container) {
      console.log('Found container, initializing renderer');
      new IPhoneRenderer(container);
    } else {
      console.error('Container not found');
    }
  });
</script>

<style>
  #iphone-container {
    display: block;
    width: 100%;
    height: 100%;
  }
  
  #canvas-container {
    position: relative;
    width: 100%;
    height: 100%;
  }
  
  #canvas-container canvas {
    width: 100% !important;
    height: 100% !important;
  }
</style>